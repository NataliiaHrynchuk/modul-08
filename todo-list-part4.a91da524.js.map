{"version":3,"sources":["js/todo-list-part4.js"],"names":["console","log","items","itemTemplate","id","isDone","text","refs","ul","document","querySelector","form","loadData","JSON","parse","localStorage","getItem","error","message","saveData","setItem","stringify","handleIsDoneChange","event","parent","target","closest","dataset","map","item","renderList","handleDeleteItem","filter","handleSubmit","preventDefault","elements","todoText","value","newItem","Date","now","toString","push","reset","toggleItem","deleteItem","handleListClick","currentTarget","nodeName","list","join","innerHTML","insertAdjacentHTML","addEventListener"],"mappings":";AAAAA,QAAQC,IAAI,cAEZ,IAAIC,EAAQ,GAEZ,MAAMC,EAAe,EAAGC,GAAAA,EAAIC,OAAAA,EAAQC,KAAAA,uBACrBF,0CAEYC,EAAS,UAAY,kBACtCC,gDAKJC,EAAO,CACXC,GAAIC,SAASC,cAAc,MAC3BC,KAAMF,SAASC,cAAc,SAOzBE,EAAW,KACX,IACFV,EAAQW,KAAKC,MAAMC,aAAaC,QAAQ,UACxC,MAAMC,GACNf,EAAQ,GACRF,QAAQC,IAAIgB,EAAMC,WAKhBC,EAAW,KACfJ,aAAaK,QAAQ,QAASP,KAAKQ,UAAUnB,KAGzCoB,EAAsBC,IACtBC,MAAAA,EAASD,EAAME,OAAOC,QAAQ,OAC9B,GAACtB,GAAMoB,EAAOG,QACpBzB,EAAQA,EAAM0B,IAAIC,GAAQA,EAAKzB,KAAOA,EAAK,IACtCyB,EACHxB,QAASwB,EAAKxB,QACZwB,GAIJ7B,QAAQC,IAAIG,GACZ0B,KAGMC,EAAoBR,IACpBC,MAAAA,EAASD,EAAME,OAAOC,QAAQ,OAC9B,GAACtB,GAAMoB,EAAOG,QACpBzB,EAAQA,EAAM8B,OAAOH,GAAQA,EAAKzB,KAAOA,GACzC0B,KAGMG,EAAgBV,IACtBA,EAAMW,iBAMA5B,MAAAA,EAAOiB,EAAME,OAAOU,SAASC,SAASC,MAEtCC,EAAU,CACdlC,GAAImC,KAAKC,MAAMC,WACfnC,KAAAA,EACAD,QAAQ,GAIVH,EAAMwC,KAAKJ,GACXnB,IACAW,IACAvB,EAAKI,KAAKgC,SAGJC,EAAcxC,IAOpBF,EAAQA,EAAM0B,IAAIC,GAAQA,EAAKzB,KAAOA,EACpC,IACGyB,EACHxB,QAASwB,EAAKxB,QAEdwB,IAEIgB,EAAczC,IACpBJ,QAAQC,IAAI,UACZC,EAAQA,EAAM8B,OAAOH,GAAQA,EAAKzB,KAAOA,IAInC0C,EAAmBvB,IACrBA,GAAAA,EAAME,SAAWF,EAAMwB,cAAe,OAEpCvB,MAAAA,EAASD,EAAME,OAAOC,QAAQ,OAG9B,GAACtB,GAAMoB,EAAOG,QAMZJ,OAAAA,EAAME,OAAOuB,UAChB,IAAA,QACHJ,EAAWxC,GACX,MACG,IAAA,SACHyC,EAAWzC,GAKbe,IACAW,KAKMA,EAAa,KAEbmB,MAAAA,EAAO/C,EAAM0B,IAAIzB,GAAc+C,KAAK,IAE1C3C,EAAKC,GAAG2C,UAAY,GACpB5C,EAAKC,GAAG4C,mBAAmB,YAAaH,IAKxC1C,EAAKI,KAAK0C,iBAAiB,SAAUpB,GACrC1B,EAAKC,GAAG6C,iBAAiB,QAASP,GAClClC,IACAkB","file":"todo-list-part4.a91da524.js","sourceRoot":"../src","sourcesContent":["console.log('Module 8.2');\n\nlet items = [];\n\nconst itemTemplate = ({ id, isDone, text }) => `\n<li data-id=\"${id}\">\n<label>\n  <input type=\"checkbox\" ${isDone ? 'checked' : ''} />\n  <span>${text}</span>\n</label>\n<button>x</button>\n</li>`; //в інпута якщо isDone true, то стан checked, якщо false, то нічого\n\nconst refs = {\n  ul: document.querySelector('ul'),\n  form: document.querySelector('form'),\n  };//Посилання на елементи, які у нас є: список (ul) і форма (form)\n//--я хочу, щоб кожного разу при зміні даних ці зміни зберігались, а коли\n//-- я наступного разу відкрию сторінку, то в мене був би список, який \n//-- зберігся з минулого разу\n\n//--ф-ція loadData буде завантажувати дані\nconst loadData = () => {\n  try {\n    items = JSON.parse(localStorage.getItem('todos'));\n  } catch(error) {\n    items = [];\n    console.log(error.message);\n  }\n};\n\n//--ф-ція saveData буде зберігати дані\nconst saveData = () => {\n  localStorage.setItem('todos', JSON.stringify(items));\n};\n\nconst handleIsDoneChange = (event) => {\nconst parent = event.target.closest('li');//батьківський елемент клікнутого\nconst {id} = parent.dataset;\nitems = items.map(item => item.id === id ? {\n  ...item,\n  isDone: !item.isDone,\n} : item);// Мепаємо наші ітемс. Якщо id поточного item дорівнює id, тоді \n// повертаємо новий об'єкт, який ми змінимо. В іншому випадку повертаємо те, \n// що було раніше. В новому об'єкті розпилюємо дані, які були до того, \n// тільки змінюємо значення isDone на не Done\nconsole.log(id);//видає батьківський id клікнутого ел-та\nrenderList();\n};\n\nconst handleDeleteItem = (event) => {\nconst parent = event.target.closest('li');//батьківський елемент клікнутого\nconst {id} = parent.dataset;\nitems = items.filter(item => item.id !== id);//У списку залишаються ті, по яких не клацнули\nrenderList();\n};\n// ---Опрацьовуємо івент сабміта-----\nconst handleSubmit = (event) => {\nevent.preventDefault();\n// console.log(event);\n// console.log(event.target);\n// console.log(event.target.elements);\n// console.log(event.target.elements.todoText);\n// console.log(event.target.elements.todoText.value);\nconst text = event.target.elements.todoText.value;\n//--створюємо новий об'єкт--\nconst newItem = {\n  id: Date.now().toString(), //к-сть мілісекунд від 01.01.1970 перводимо в текст\n  text, \n  isDone: false,\n};\n// console.log(newItem);\n//---пушимо новостворений об'єкт в айтеми----\nitems.push(newItem);\nsaveData();//збереження даних\nrenderList();//формуємо новий список\nrefs.form.reset();//очищаємо поле для введення після кожного івенту\n};\n\nconst toggleItem = (id) => {\n// console.log('check');\n//--ф-ція, яка зберігає чекнуті інпути при додаванні нового елемента списку\n// ---перебираємо всі items і шукаємо з них той, що по id співпадає з поточним id.\n//--якщо співпадає, то для нього створимо новий item, який буде складатись\n//-- з усього, що там було раніше, а значення isDone запишемо, як !item.isDone,\n//-- в іншому випадку залишаємо все, як є\nitems = items.map(item => item.id === id \n? {\n  ...item,\n  isDone: !item.isDone,\n} \n: item);\n};\nconst deleteItem = (id) => {\nconsole.log('delete');\nitems = items.filter(item => item.id !== id);//в новий список потрапляють лише ті item, у яких\n// id не співпадає з id елемента, на кнопку якого клікнули\n}\n\nconst handleListClick = (event) => {\nif (event.target === event.currentTarget) return;// якщо клік припадає на ul, то виходимо з ф-ції\n//  console.log(event.target);//щоб зрозуміти, на який item ми потрапили при кліку\nconst parent = event.target.closest('li');// ми хочемо, щоб, куди ми не клікнули, \n//  отримати батьківський ел-т li, у якого можна взяти id\n//  console.log(parent);\nconst {id} = parent.dataset;//отримуємо id елемента списку, по якому клікнули\n//  console.log(id);\n//--щоб подивитись, яка Node-назва в елемента, на який ми клікнули--\n//--буде великимилітерами LI, BUTTON чи INPUT:\n// console.log(event.target.nodeName);\n//розмежуємо кліки на кнопку і на input:\nswitch (event.target.nodeName) {\ncase 'INPUT':\n  toggleItem(id);\n  break;\ncase 'BUTTON':\n  deleteItem(id);\n  break;\ndefault:\n  break;\n}\nsaveData();//збереження даних\nrenderList();//формуємо новий список\n};\n\n//-----Ф-ція, яка видаляє всі попередні елементи зі списку і генерує нам \n// новий список, який ми підготували через items.map ----------\nconst renderList = () => {\n  \nconst list = items.map(itemTemplate).join(''); \n// console.log(list);\nrefs.ul.innerHTML = '';\nrefs.ul.insertAdjacentHTML('beforeend', list);\n\n// console.log(items);//виводить сформований список \n};\n\nrefs.form.addEventListener('submit', handleSubmit);// Підписка на сабміт\nrefs.ul.addEventListener('click', handleListClick);\nloadData();//завантаження даних\nrenderList();//Генеруємо список перший раз після старту програми з масиву, який в нас є\n"]}